-VARIABLES-

int i = 0


-CONST-
int: fixed i = 0
i = 4 // error




-REF-
int: fixed x = 44
int: ref i = x

print(i) // error
print(#i) //! dereference op: #








-KEYWORDS-
null
nullref
default

class myClass{
	default(){
		return new myClass(0, 5, "className")
	}
	//declares a static function
	void:static myStaticFunction(int:ref myintref){
		myintref += 5
		
	}

}
int __func()
{
	myClass m = default //sets refint to a default value provided by the type
	m = null

	m.doSomething() //is null, but will only cause warning, function will not be called
	m = nullref //will throw error, a variable that is not a refrence cannot be nullref

}


--if statements--

#1 = if(condition<bool>)

#2 = if(value<type> (operator) value<type>)

#3 = if(?value) //checks if the value is not null

#4 = if(^ (and | or) ^ )// ^ = any above

--approaching if statements--

BoolExpr left;
Operator op = null;
BoolExpr right = null;

finds 'if' -> 
	left = () => {
		finds '(' -> () => { 
			return VContainer of everything parsed before comparison operator
		}
		else ERR
	} ->
	finds LOGICALOP -> 
		op = () => {-> parse and return Operator } ->
		right = () => {return VContainer of everything parsed after comparison op and before last ')'} ->
		skip to token after '{' ->
		BREAK
	else: 
		return bool expr #1 then END


	CREATE BoolExpr obj(left, op, right)

	call BoolExpr.evaluate()

	parse result, if true:
		continue parse
	else:
		skip to end of '}' and return

--while statements--

while(boolExpr){}




--ARRAYS--

ARRAY (LIST):

	list[?][?:int] <name> ?= [?]

	list[?] <name>[?:int]

	list mymixedarray = [1, 1.245, "test"] -> accepts any type

	list[int] myfixedarray = [1, 3 , 4, 66] -> accepts any type in the container specifier

	list[^] myfixedsizearray[2] = [1, 2, 3] -> accepts an integer to specify the size

	--ARRAY ACCESSIBILITY--

	list mylist[1+] // must always contain 2 or more items

	list mylist[1-] // must always contain 2 or less items

	--accessing arrays--


	mylist[:4] //splicing

	mylist[4:]

	mylist[4::]


--DYNAMIC OBJECTS--

	obj <name> ?= 
	{
		<key>:name : <value>:type , ? repeat
	}

	obj myobject = {string ip: '192.168.0.1', int port: 4444}

--TUPLES--

	tuple[list: type[1+]] <name> ?= tuple(list:val) 


	tuple[int, string] mytuple = tuple(1, "my tuple string")




--LIBRARY IDEAS--

	EMAIL:
		desc:  a library for easily sending emails over the web
		usage:
			
			Emailer mailer = new EMailer({username, password}, {sender_username})

			class Email;

			Email myemail = Emailer@createEmail(subject, [recipients], content)

			mailer.compose(Email) //creates a draft with an email object

			mailer.send() //sends the email

			Email draft = mailer.erase() //gets rid of the draft, and returns the deleted draft
	FILE SYS:
		desc: an inb library for communicating with the filesystem
		usage:
			
			string fileContent = read(filePath)

			List[String] lines = readLines(filePath)


--USING FILES--

	first (0): use <name (.?...)> (from <source(.?...)>)?
	second (1): from <source(.?...)> use <name(.?...)>
